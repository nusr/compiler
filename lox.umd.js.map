{
  "version": 3,
  "sources": ["../src/index.ts", "../src/token.ts", "../src/error.ts", "../src/util.ts", "../src/scanner.ts", "../src/expression.ts", "../src/statement.ts", "../src/parser.ts", "../src/eventEmitter.ts", "../src/environment.ts", "../src/expect.ts", "../src/loxCallable.ts", "../src/returnValue.ts", "../src/interpreter.ts", "../src/debug.ts", "../src/native.ts", "../src/lox.ts"],
  "sourcesContent": ["import { Lox } from './lox';\r\nimport eventEmitter from './eventEmitter';\r\nimport { defaultErrorHandler } from './error';\r\nimport globalExpect from './expect';\r\nimport Environment from './environment';\r\nexport { eventEmitter, Lox, defaultErrorHandler, globalExpect, Environment };\r\n", "import type { TokenType } from './tokenType';\r\nimport type { LiteralType } from './type';\r\nclass Token {\r\n  readonly type: TokenType;\r\n  readonly lexeme: string;\r\n  readonly literal: LiteralType;\r\n  readonly line: number;\r\n\r\n  constructor(\r\n    type: TokenType,\r\n    lexeme: string,\r\n    literal: LiteralType,\r\n    line: number,\r\n  ) {\r\n    this.type = type;\r\n    this.lexeme = lexeme;\r\n    this.literal = literal;\r\n    this.line = line;\r\n  }\r\n\r\n  public toString() {\r\n    return this.type + ' ' + this.lexeme + ' ' + this.literal;\r\n  }\r\n}\r\n\r\nexport default Token;\r\n", "import type Token from './token';\r\nfunction errorHandler() {\r\n  const errorList: string[] = [];\r\n  let hadError = false;\r\n  const report = (line: number, where: string, message: string) => {\r\n    const msg = `[line ${line}] Error ${where} : ${message} `;\r\n    errorList.push(msg);\r\n    console.log(msg);\r\n    hadError = true;\r\n  };\r\n  const error = (line: number, message: string) => {\r\n    report(line, '', message);\r\n  };\r\n  const get = () => {\r\n    return hadError;\r\n  };\r\n  const reset = () => {\r\n    if (errorList.length > 0) {\r\n      console.log('error list:', errorList);\r\n    }\r\n    hadError = false;\r\n  };\r\n  return {\r\n    error,\r\n    get,\r\n    reset,\r\n  };\r\n}\r\n\r\nclass RuntimeError extends Error {\r\n  constructor(token: Token, message: string) {\r\n    super(`runtime error: ${token.toString()},message: ${message}`);\r\n  }\r\n}\r\n\r\nconst defaultErrorHandler = errorHandler();\r\nexport { defaultErrorHandler, errorHandler, RuntimeError };\r\n", "import type { LiteralType, BaseCallable } from './type';\r\n\r\nexport function convertLiteralTypeToString(val: LiteralType): string {\r\n  if (val === null) {\r\n    return 'null';\r\n  }\r\n  if (typeof val === 'string') {\r\n    return val;\r\n  }\r\n  if (typeof val === 'boolean') {\r\n    return val.toString();\r\n  }\r\n  if (typeof val === 'number') {\r\n    return val.toString();\r\n  }\r\n  if (val && typeof val.toString === 'function') {\r\n    return val.toString();\r\n  }\r\n  return '';\r\n}\r\n\r\nfunction isFunction(fun: any): fun is Function {\r\n  return typeof fun === 'function';\r\n}\r\n\r\nexport function isBaseCallable(call: any): call is BaseCallable {\r\n  return (\r\n    'size' in call &&\r\n    'toString' in call &&\r\n    'call' in call &&\r\n    isFunction(call.size) &&\r\n    isFunction(call.toString) &&\r\n    isFunction(call.call)\r\n  );\r\n}\r\n\r\nexport function getVersion(): string {\r\n  // @ts-ignore\r\n  return process.env.VERSION;\r\n}\r\n\r\nexport function isTestEnv(): boolean {\r\n  // @ts-ignore\r\n  return process.env.NODE_ENV === 'test';\r\n}\r\n", "import Token from './token';\r\nimport { TokenType } from './tokenType';\r\nimport { defaultErrorHandler } from './error';\r\nimport type { LiteralType } from './type';\r\nimport { isTestEnv } from './util';\r\nconst EMPTY_DATA = '\\0';\r\n\r\nclass Scanner {\r\n  readonly source: string;\r\n  readonly tokens: Token[] = [];\r\n  static readonly keywordMap: Map<string, TokenType> = new Map([\r\n    ['class', TokenType.CLASS],\r\n    ['else', TokenType.ELSE],\r\n    ['false', TokenType.FALSE],\r\n    ['for', TokenType.FOR],\r\n    ['fun', TokenType.FUN],\r\n    ['if', TokenType.IF],\r\n    ['null', TokenType.NIL],\r\n    ['print', TokenType.PRINT],\r\n    ['return', TokenType.RETURN],\r\n    ['super', TokenType.SUPER],\r\n    ['this', TokenType.THIS],\r\n    ['true', TokenType.TRUE],\r\n    ['var', TokenType.VAR],\r\n    ['while', TokenType.WHILE],\r\n  ]);\r\n  private start = 0;\r\n  private current = 0;\r\n  private line = 1;\r\n\r\n  constructor(text: string) {\r\n    this.source = text;\r\n  }\r\n  scanTokens = () => {\r\n    while (!this.isAtEnd()) {\r\n      this.start = this.current;\r\n      this.scanToken();\r\n    }\r\n    this.tokens.push(new Token(TokenType.EOF, '', null, this.line));\r\n    return this.tokens;\r\n  };\r\n  private isAtEnd() {\r\n    return this.current >= this.source.length;\r\n  }\r\n  private addToken(type: TokenType) {\r\n    this.addOneToken(type, null);\r\n  }\r\n  private addOneToken(type: TokenType, literal: LiteralType) {\r\n    const text = this.source.substring(this.start, this.current);\r\n    this.tokens.push(new Token(type, text, literal, this.line));\r\n  }\r\n  private getChar(index: number) {\r\n    return this.source.charAt(index);\r\n  }\r\n  private peek() {\r\n    if (this.isAtEnd()) {\r\n      return EMPTY_DATA;\r\n    }\r\n    return this.getChar(this.current);\r\n  }\r\n  private peekNext() {\r\n    if (this.current + 1 < this.source.length) {\r\n      return this.getChar(this.current + 1);\r\n    }\r\n    return EMPTY_DATA;\r\n  }\r\n  private match(expected: string) {\r\n    if (this.isAtEnd()) {\r\n      return false;\r\n    }\r\n    if (this.getChar(this.current) !== expected) {\r\n      return false;\r\n    }\r\n\r\n    this.current++;\r\n    return true;\r\n  }\r\n  private advance() {\r\n    return this.getChar(this.current++);\r\n  }\r\n  private scanToken() {\r\n    const c = this.advance();\r\n    switch (c) {\r\n      case '(':\r\n        this.addToken(TokenType.LEFT_PAREN);\r\n        break;\r\n      case ')':\r\n        this.addToken(TokenType.RIGHT_PAREN);\r\n        break;\r\n      case '{':\r\n        this.addToken(TokenType.lEFT_BRACE);\r\n        break;\r\n      case '}':\r\n        this.addToken(TokenType.RIGHT_BRACE);\r\n        break;\r\n      case ',':\r\n        this.addToken(TokenType.COMMA);\r\n        break;\r\n      case '.':\r\n        this.addToken(TokenType.DOT);\r\n        break;\r\n      case '-':\r\n        this.addToken(TokenType.MINUS);\r\n        break;\r\n      case '+':\r\n        this.addToken(TokenType.PLUS);\r\n        break;\r\n      case ';':\r\n        this.addToken(TokenType.SEMICOLON);\r\n        break;\r\n      case '*':\r\n        this.addToken(TokenType.STAR);\r\n        break;\r\n      case '!':\r\n        this.addToken(this.match('=') ? TokenType.BANG_EQUAL : TokenType.BANG);\r\n        break;\r\n      case '=':\r\n        this.addToken(\r\n          this.match('=') ? TokenType.EQUAL_EQUAL : TokenType.EQUAL,\r\n        );\r\n        break;\r\n      case '>':\r\n        this.addToken(\r\n          this.match('=') ? TokenType.GREATER_EQUAL : TokenType.GREATER,\r\n        );\r\n        break;\r\n      case '<':\r\n        this.addToken(this.match('=') ? TokenType.LESS_EQUAL : TokenType.LESS);\r\n        break;\r\n      case '/':\r\n        // single line comment\r\n        if (this.match('/')) {\r\n          while (this.peek() !== '\\n' && !this.isAtEnd()) {\r\n            this.advance();\r\n          }\r\n          if (isTestEnv()) {\r\n            const text = this.source.substring(this.start, this.current);\r\n            if (\r\n              text.includes('expect:') &&\r\n              this.tokens.some((v) => v.type === TokenType.PRINT)\r\n            ) {\r\n              const t = text.split(':').pop() || '';\r\n              if (t.trim()) {\r\n                this.tokens.push(\r\n                  new Token(TokenType.LINE_COMMENT, t.trim(), null, this.line),\r\n                );\r\n              }\r\n            }\r\n          }\r\n        } else if (this.match('*')) {\r\n          /* multiple line comments */\r\n          while (\r\n            !(\r\n              (this.peek() === '*' && this.peekNext() === '/') ||\r\n              this.isAtEnd()\r\n            )\r\n          ) {\r\n            this.advance();\r\n          }\r\n          if (this.peekNext() !== '/') {\r\n            defaultErrorHandler.error(\r\n              this.line,\r\n              'multiple line comment end error',\r\n            );\r\n          }\r\n          this.advance(); // skip *\r\n          this.advance(); // skip /\r\n        } else {\r\n          this.addToken(TokenType.SLASH);\r\n        }\r\n        break;\r\n      case '|':\r\n        if (this.match('|')) {\r\n          this.addToken(TokenType.OR);\r\n        } else {\r\n          this.addToken(TokenType.BIT_OR);\r\n        }\r\n        break;\r\n      case '&':\r\n        if (this.match('&')) {\r\n          this.addToken(TokenType.AND);\r\n        } else {\r\n          this.addToken(TokenType.BIT_AND);\r\n        }\r\n        break;\r\n      case ' ':\r\n      case '\\r':\r\n      case '\\t':\r\n        // whitespace\r\n        break;\r\n      case '\\n':\r\n        this.line++;\r\n        break;\r\n      case '\"':\r\n        this.string();\r\n        break;\r\n      default:\r\n        if (this.isDigit(c)) {\r\n          this.number();\r\n        } else if (this.isAlpha(c)) {\r\n          this.identifier();\r\n        } else {\r\n          defaultErrorHandler.error(this.line, `Unexpected character: ${c}`);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n  private string() {\r\n    while (this.peek() !== '\"' && !this.isAtEnd()) {\r\n      if (this.peek() === '\\n') {\r\n        this.line++;\r\n      }\r\n      this.advance();\r\n    }\r\n    if (this.isAtEnd()) {\r\n      defaultErrorHandler.error(this.line, 'Unterminated string');\r\n      return;\r\n    }\r\n    this.advance();\r\n    const value = this.source.substring(this.start + 1, this.current - 1);\r\n    this.addOneToken(TokenType.STRING, value);\r\n  }\r\n  private number() {\r\n    while (this.isDigit(this.peek())) {\r\n      this.advance();\r\n    }\r\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\r\n      this.advance();\r\n      while (this.isDigit(this.peek())) {\r\n        this.advance();\r\n      }\r\n    }\r\n    const value = this.source.substring(this.start, this.current);\r\n    this.addOneToken(TokenType.NUMBER, parseFloat(value));\r\n  }\r\n  private identifier() {\r\n    while (this.isAlphaNumeric(this.peek())) {\r\n      this.advance();\r\n    }\r\n    const text = this.source.substring(this.start, this.current);\r\n    const temp = Scanner.keywordMap.get(text);\r\n    let type: TokenType = TokenType.IDENTIFIER;\r\n    if (temp !== undefined) {\r\n      type = temp;\r\n    }\r\n    this.addToken(type);\r\n  }\r\n  private isAlphaNumeric(c: string) {\r\n    return this.isAlpha(c) || this.isDigit(c);\r\n  }\r\n  private isAlpha(c: string) {\r\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '_';\r\n  }\r\n  private isDigit(char: string) {\r\n    return char >= '0' && char <= '9';\r\n  }\r\n}\r\nexport default Scanner;\r\n", "import type Token from './token';\nimport type { LiteralType } from './type';\nexport interface ExpressionVisitor<T> {\n  visitAssignExpression: (expression: AssignExpression<T>) => T;\n  visitBinaryExpression: (expression: BinaryExpression<T>) => T;\n  visitCallExpression: (expression: CallExpression<T>) => T;\n  visitGetExpression: (expression: GetExpression<T>) => T;\n  visitSetExpression: (expression: SetExpression<T>) => T;\n  visitGroupingExpression: (expression: GroupingExpression<T>) => T;\n  visitLiteralExpression: (expression: LiteralExpression<T>) => T;\n  visitLogicalExpression: (expression: LogicalExpression<T>) => T;\n  visitSuperExpression: (expression: SuperExpression<T>) => T;\n  visitThisExpression: (expression: ThisExpression<T>) => T;\n  visitUnaryExpression: (expression: UnaryExpression<T>) => T;\n  visitVariableExpression: (expression: VariableExpression<T>) => T;\n}\nexport abstract class Expression<T> {\n  abstract accept(visitor: ExpressionVisitor<T>): T;\n}\nexport class AssignExpression<T> extends Expression<T> {\n  readonly name: Token;\n  readonly value: Expression<T>;\n  constructor(name: Token, value: Expression<T>) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitAssignExpression(this);\n  }\n}\nexport class BinaryExpression<T> extends Expression<T> {\n  readonly left: Expression<T>;\n  readonly operator: Token;\n  readonly right: Expression<T>;\n  constructor(left: Expression<T>, operator: Token, right: Expression<T>) {\n    super();\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitBinaryExpression(this);\n  }\n}\nexport class CallExpression<T> extends Expression<T> {\n  readonly callee: Expression<T>;\n  readonly paren: Token;\n  readonly argumentList: Expression<T>[];\n  constructor(\n    callee: Expression<T>,\n    paren: Token,\n    argumentList: Expression<T>[],\n  ) {\n    super();\n    this.callee = callee;\n    this.paren = paren;\n    this.argumentList = argumentList;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitCallExpression(this);\n  }\n}\nexport class GetExpression<T> extends Expression<T> {\n  readonly object: Expression<T>;\n  readonly name: Token;\n  constructor(object: Expression<T>, name: Token) {\n    super();\n    this.object = object;\n    this.name = name;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitGetExpression(this);\n  }\n}\nexport class SetExpression<T> extends Expression<T> {\n  readonly object: Expression<T>;\n  readonly name: Token;\n  readonly value: Expression<T>;\n  constructor(object: Expression<T>, name: Token, value: Expression<T>) {\n    super();\n    this.object = object;\n    this.name = name;\n    this.value = value;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitSetExpression(this);\n  }\n}\nexport class GroupingExpression<T> extends Expression<T> {\n  readonly expression: Expression<T>;\n  constructor(expression: Expression<T>) {\n    super();\n    this.expression = expression;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitGroupingExpression(this);\n  }\n}\nexport class LiteralExpression<T> extends Expression<T> {\n  readonly value: LiteralType;\n  constructor(value: LiteralType) {\n    super();\n    this.value = value;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitLiteralExpression(this);\n  }\n}\nexport class LogicalExpression<T> extends Expression<T> {\n  readonly left: Expression<T>;\n  readonly operator: Token;\n  readonly right: Expression<T>;\n  constructor(left: Expression<T>, operator: Token, right: Expression<T>) {\n    super();\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitLogicalExpression(this);\n  }\n}\nexport class SuperExpression<T> extends Expression<T> {\n  readonly keyword: Token;\n  readonly value: Expression<T>;\n  constructor(keyword: Token, value: Expression<T>) {\n    super();\n    this.keyword = keyword;\n    this.value = value;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitSuperExpression(this);\n  }\n}\nexport class ThisExpression<T> extends Expression<T> {\n  readonly keyword: Token;\n  constructor(keyword: Token) {\n    super();\n    this.keyword = keyword;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitThisExpression(this);\n  }\n}\nexport class UnaryExpression<T> extends Expression<T> {\n  readonly operator: Token;\n  readonly right: Expression<T>;\n  constructor(operator: Token, right: Expression<T>) {\n    super();\n    this.operator = operator;\n    this.right = right;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitUnaryExpression(this);\n  }\n}\nexport class VariableExpression<T> extends Expression<T> {\n  readonly name: Token;\n  constructor(name: Token) {\n    super();\n    this.name = name;\n  }\n  accept(visitor: ExpressionVisitor<T>): T {\n    return visitor.visitVariableExpression(this);\n  }\n}\n", "import type Token from './token';\nimport type { Expression, VariableExpression } from './expression';\nexport interface StatementVisitor<T> {\n  visitBlockStatement: (statement: BlockStatement<T>) => T;\n  visitClassStatement: (statement: ClassStatement<T>) => T;\n  visitExpressionStatement: (statement: ExpressionStatement<T>) => T;\n  visitFunctionStatement: (statement: FunctionStatement<T>) => T;\n  visitIfStatement: (statement: IfStatement<T>) => T;\n  visitPrintStatement: (statement: PrintStatement<T>) => T;\n  visitReturnStatement: (statement: ReturnStatement<T>) => T;\n  visitVariableStatement: (statement: VariableStatement<T>) => T;\n  visitWhileStatement: (statement: WhileStatement<T>) => T;\n}\nexport abstract class Statement<T> {\n  abstract accept(visitor: StatementVisitor<T>): T;\n}\nexport class BlockStatement<T> extends Statement<T> {\n  readonly statements: Statement<T>[];\n  constructor(statements: Statement<T>[]) {\n    super();\n    this.statements = statements;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitBlockStatement(this);\n  }\n}\nexport class ClassStatement<T> extends Statement<T> {\n  readonly name: Token;\n  readonly superClass: VariableExpression<T>;\n  readonly methods: FunctionStatement<T>[];\n  constructor(\n    name: Token,\n    superClass: VariableExpression<T>,\n    methods: FunctionStatement<T>[],\n  ) {\n    super();\n    this.name = name;\n    this.superClass = superClass;\n    this.methods = methods;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitClassStatement(this);\n  }\n}\nexport class ExpressionStatement<T> extends Statement<T> {\n  readonly expression: Expression<T>;\n  constructor(expression: Expression<T>) {\n    super();\n    this.expression = expression;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitExpressionStatement(this);\n  }\n}\nexport class FunctionStatement<T> extends Statement<T> {\n  readonly name: Token;\n  readonly body: BlockStatement<T>;\n  readonly params: Token[];\n  constructor(name: Token, body: BlockStatement<T>, params: Token[]) {\n    super();\n    this.name = name;\n    this.body = body;\n    this.params = params;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitFunctionStatement(this);\n  }\n}\nexport class IfStatement<T> extends Statement<T> {\n  readonly condition: Expression<T>;\n  readonly thenBranch: Statement<T>;\n  readonly elseBranch: Statement<T> | null;\n  constructor(\n    condition: Expression<T>,\n    thenBranch: Statement<T>,\n    elseBranch: Statement<T> | null,\n  ) {\n    super();\n    this.condition = condition;\n    this.thenBranch = thenBranch;\n    this.elseBranch = elseBranch;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitIfStatement(this);\n  }\n}\nexport class PrintStatement<T> extends Statement<T> {\n  readonly expression: Expression<T>;\n  readonly comment: Token | null;\n  constructor(expression: Expression<T>, comment: Token | null) {\n    super();\n    this.expression = expression;\n    this.comment = comment;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitPrintStatement(this);\n  }\n}\nexport class ReturnStatement<T> extends Statement<T> {\n  readonly keyword: Token;\n  readonly value: Expression<T> | null;\n  constructor(keyword: Token, value: Expression<T> | null) {\n    super();\n    this.keyword = keyword;\n    this.value = value;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitReturnStatement(this);\n  }\n}\nexport class VariableStatement<T> extends Statement<T> {\n  readonly name: Token;\n  readonly initializer: Expression<T> | null;\n  constructor(name: Token, initializer: Expression<T> | null) {\n    super();\n    this.name = name;\n    this.initializer = initializer;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitVariableStatement(this);\n  }\n}\nexport class WhileStatement<T> extends Statement<T> {\n  readonly condition: Expression<T>;\n  readonly body: Statement<T>;\n  constructor(condition: Expression<T>, body: Statement<T>) {\n    super();\n    this.condition = condition;\n    this.body = body;\n  }\n  accept(visitor: StatementVisitor<T>): T {\n    return visitor.visitWhileStatement(this);\n  }\n}\n", "import {\r\n  AssignExpression,\r\n  BinaryExpression,\r\n  CallExpression,\r\n  Expression,\r\n  GroupingExpression,\r\n  LiteralExpression,\r\n  LogicalExpression,\r\n  UnaryExpression,\r\n  VariableExpression,\r\n} from './expression';\r\nimport type { LiteralType } from './type';\r\nimport { TokenType } from './tokenType';\r\nimport Token from './token';\r\nimport {\r\n  BlockStatement,\r\n  ExpressionStatement,\r\n  FunctionStatement,\r\n  IfStatement,\r\n  PrintStatement,\r\n  ReturnStatement,\r\n  Statement,\r\n  VariableStatement,\r\n  WhileStatement,\r\n} from './statement';\r\n\r\nimport { isTestEnv } from './util';\r\n\r\nclass Parser {\r\n  private readonly tokens: Token[];\r\n  private current = 0;\r\n  constructor(tokens: Token[]) {\r\n    this.tokens = tokens;\r\n  }\r\n  parse = (): Statement<LiteralType>[] => {\r\n    const statements: Statement<LiteralType>[] = [];\r\n    while (!this.isAtEnd()) {\r\n      statements.push(this.declaration());\r\n    }\r\n    return statements;\r\n  };\r\n  private declaration(): Statement<LiteralType> {\r\n    if (this.match(TokenType.VAR)) {\r\n      return this.varStatement();\r\n    }\r\n\r\n    if (this.match(TokenType.FUN)) {\r\n      return this.funcStatement();\r\n    }\r\n\r\n    return this.statement();\r\n  }\r\n  private varStatement(): Statement<LiteralType> {\r\n    const name: Token = this.consume(\r\n      TokenType.IDENTIFIER,\r\n      'expect identifier after var',\r\n    );\r\n    let initializer: Expression<LiteralType> | null = null;\r\n    if (this.match(TokenType.EQUAL)) {\r\n      initializer = this.expression();\r\n    }\r\n    this.consume(TokenType.SEMICOLON, 'expected ; after declaration');\r\n    return new VariableStatement(name, initializer);\r\n  }\r\n  private funcStatement(): Statement<LiteralType> {\r\n    const functionName: Token = this.consume(\r\n      TokenType.IDENTIFIER,\r\n      'expect identifier after func',\r\n    );\r\n    this.consume(TokenType.LEFT_PAREN, 'expect ( after function name');\r\n    const params: Token[] = [];\r\n    if (!this.check(TokenType.RIGHT_PAREN)) {\r\n      do {\r\n        params.push(\r\n          this.consume(TokenType.IDENTIFIER, 'expect parameter name'),\r\n        );\r\n      } while (this.match(TokenType.COMMA));\r\n    }\r\n    this.consume(TokenType.RIGHT_PAREN, 'expect ) after function name');\r\n    this.consume(TokenType.lEFT_BRACE, 'expect { after function parameters');\r\n    const block = this.block();\r\n    return new FunctionStatement(functionName, block, params);\r\n  }\r\n  private statement(): Statement<LiteralType> {\r\n    if (this.match(TokenType.IF)) {\r\n      return this.ifStatement();\r\n    }\r\n    if (this.match(TokenType.PRINT)) {\r\n      return this.printStatement();\r\n    }\r\n    if (this.match(TokenType.WHILE)) {\r\n      return this.whileStatement();\r\n    }\r\n    if (this.match(TokenType.lEFT_BRACE)) {\r\n      return this.block();\r\n    }\r\n    if (this.match(TokenType.RETURN)) {\r\n      return this.returnStatement();\r\n    }\r\n    return this.expressionStatement();\r\n  }\r\n  private returnStatement(): ReturnStatement<LiteralType> {\r\n    const keyword = this.previous();\r\n    let value: Expression<LiteralType> | null = null;\r\n    if (!this.check(TokenType.SEMICOLON)) {\r\n      value = this.expression();\r\n    }\r\n    this.consume(TokenType.SEMICOLON, 'expect ; after return');\r\n    return new ReturnStatement(keyword, value);\r\n  }\r\n  private whileStatement(): Statement<LiteralType> {\r\n    this.consume(TokenType.LEFT_PAREN, 'expect ( after while');\r\n    const expression = this.expression();\r\n    this.consume(TokenType.RIGHT_PAREN, 'expect ) after while');\r\n    const body = this.statement();\r\n    return new WhileStatement<LiteralType>(expression, body);\r\n  }\r\n  private ifStatement(): Statement<LiteralType> {\r\n    this.consume(TokenType.LEFT_PAREN, 'expect ( after if');\r\n    const expression = this.expression();\r\n    this.consume(TokenType.RIGHT_PAREN, 'expect ) after if');\r\n    const thenBranch: Statement<LiteralType> = this.statement();\r\n    let elseBranch: Statement<LiteralType> | null = null;\r\n    if (this.match(TokenType.ELSE)) {\r\n      elseBranch = this.statement();\r\n    }\r\n    return new IfStatement<LiteralType>(expression, thenBranch, elseBranch);\r\n  }\r\n  private block(): BlockStatement<LiteralType> {\r\n    const statements: Statement<LiteralType>[] = [];\r\n    while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\r\n      statements.push(this.declaration());\r\n    }\r\n    this.consume(TokenType.RIGHT_BRACE, 'expect } after block');\r\n    return new BlockStatement<LiteralType>(statements);\r\n  }\r\n  private printStatement(): PrintStatement<LiteralType> {\r\n    const expr = this.expression();\r\n    if (!this.isAtEnd()) {\r\n      this.consume(TokenType.SEMICOLON, 'expected ; after print');\r\n    }\r\n    let comment: Token | null = null;\r\n    if (isTestEnv() && this.match(TokenType.LINE_COMMENT)) {\r\n      comment = this.previous();\r\n    }\r\n    return new PrintStatement<LiteralType>(expr, comment);\r\n  }\r\n  private expressionStatement(): Statement<LiteralType> {\r\n    const expr = this.expression();\r\n    if (!this.isAtEnd()) {\r\n      this.consume(TokenType.SEMICOLON, 'expected ; after expression');\r\n    }\r\n    return new ExpressionStatement<LiteralType>(expr);\r\n  }\r\n  public expression(): Expression<LiteralType> {\r\n    return this.assignment();\r\n  }\r\n  private assignment(): Expression<LiteralType> {\r\n    const expr = this.or();\r\n    if (this.match(TokenType.EQUAL)) {\r\n      const equal: Token = this.previous();\r\n      const value = this.assignment();\r\n      if (expr instanceof VariableExpression) {\r\n        const name = expr.name;\r\n        return new AssignExpression<LiteralType>(name, value);\r\n      }\r\n      throw new Error(`invalid assign target: ${equal}`);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  private or(): Expression<LiteralType> {\r\n    let expr = this.and();\r\n    while (this.match(TokenType.OR)) {\r\n      const operator = this.previous();\r\n      const right = this.and();\r\n      expr = new LogicalExpression<LiteralType>(expr, operator, right);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  private and(): Expression<LiteralType> {\r\n    let expr = this.equality();\r\n    while (this.match(TokenType.AND)) {\r\n      const operator = this.previous();\r\n      const right = this.equality();\r\n      expr = new LogicalExpression<LiteralType>(expr, operator, right);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  private equality(): Expression<LiteralType> {\r\n    let expr: Expression<LiteralType> = this.comparison();\r\n    while (this.match(TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL)) {\r\n      const operator: Token = this.previous();\r\n      const right: Expression<LiteralType> = this.comparison();\r\n      expr = new BinaryExpression(expr, operator, right);\r\n    }\r\n    return expr;\r\n  }\r\n  private comparison(): Expression<LiteralType> {\r\n    let term: Expression<LiteralType> = this.term();\r\n    while (\r\n      this.match(\r\n        TokenType.GREATER,\r\n        TokenType.GREATER_EQUAL,\r\n        TokenType.LESS,\r\n        TokenType.LESS_EQUAL,\r\n      )\r\n    ) {\r\n      const operator: Token = this.previous();\r\n      const right: Expression<LiteralType> = this.term();\r\n      term = new BinaryExpression(term, operator, right);\r\n    }\r\n    return term;\r\n  }\r\n  private term(): Expression<LiteralType> {\r\n    let factor: Expression<LiteralType> = this.factor();\r\n    while (this.match(TokenType.PLUS, TokenType.MINUS)) {\r\n      const operator: Token = this.previous();\r\n      const right: Expression<LiteralType> = this.factor();\r\n      factor = new BinaryExpression(factor, operator, right);\r\n    }\r\n    return factor;\r\n  }\r\n  private factor(): Expression<LiteralType> {\r\n    let unary: Expression<LiteralType> = this.unary();\r\n    while (this.match(TokenType.STAR, TokenType.SLASH)) {\r\n      const operator: Token = this.previous();\r\n      const right: Expression<LiteralType> = this.unary();\r\n      unary = new BinaryExpression(unary, operator, right);\r\n    }\r\n    return unary;\r\n  }\r\n  private unary(): Expression<LiteralType> {\r\n    if (this.match(TokenType.MINUS, TokenType.BANG)) {\r\n      const operator: Token = this.previous();\r\n      const value = this.unary();\r\n      return new UnaryExpression(operator, value);\r\n    }\r\n    return this.call();\r\n  }\r\n  private call(): Expression<LiteralType> {\r\n    let expr: Expression<LiteralType> = this.primary();\r\n    while (true) {\r\n      if (this.match(TokenType.LEFT_PAREN)) {\r\n        expr = this.finishCall(expr);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return expr;\r\n  }\r\n  private finishCall(callee: Expression<LiteralType>): Expression<LiteralType> {\r\n    const params: Expression<LiteralType>[] = [];\r\n    if (!this.check(TokenType.RIGHT_PAREN)) {\r\n      do {\r\n        params.push(this.expression());\r\n      } while (this.match(TokenType.COMMA));\r\n    }\r\n    const paren = this.consume(\r\n      TokenType.RIGHT_PAREN,\r\n      'expect ) after arguments',\r\n    );\r\n    return new CallExpression(callee, paren, params);\r\n  }\r\n\r\n  private primary(): Expression<LiteralType> {\r\n    if (this.match(TokenType.TRUE)) {\r\n      return new LiteralExpression(true);\r\n    }\r\n    if (this.match(TokenType.FALSE)) {\r\n      return new LiteralExpression(false);\r\n    }\r\n    if (this.match(TokenType.NIL)) {\r\n      return new LiteralExpression(null);\r\n    }\r\n    if (this.match(TokenType.NUMBER, TokenType.STRING)) {\r\n      return new LiteralExpression(this.previous().literal);\r\n    }\r\n    if (this.match(TokenType.IDENTIFIER)) {\r\n      return new VariableExpression(this.previous());\r\n    }\r\n    if (this.match(TokenType.LEFT_PAREN)) {\r\n      const expr: Expression<LiteralType> = this.expression();\r\n      this.consume(\r\n        TokenType.RIGHT_PAREN,\r\n        `parser expected: '(',actual: ${JSON.stringify(this.peek())}`,\r\n      );\r\n      return new GroupingExpression(expr);\r\n    }\r\n\r\n    throw new Error(\r\n      `parser can not handle token: ${JSON.stringify(this.peek())}`,\r\n    );\r\n  }\r\n  private consume(type: TokenType, message: string) {\r\n    if (this.peek().type === type) {\r\n      this.advance();\r\n      return this.previous();\r\n    }\r\n    throw new Error(message);\r\n  }\r\n  private previous(): Token {\r\n    return this.tokens[this.current - 1] as Token;\r\n  }\r\n  private match(...types: TokenType[]): boolean {\r\n    for (let type of types) {\r\n      if (this.check(type)) {\r\n        this.advance();\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  private advance() {\r\n    if (this.isAtEnd()) {\r\n      return;\r\n    }\r\n    this.current++;\r\n  }\r\n  private check(type: TokenType) {\r\n    if (this.isAtEnd()) {\r\n      return false;\r\n    }\r\n    return this.peek().type === type;\r\n  }\r\n  private isAtEnd(): boolean {\r\n    return this.peek().type === TokenType.EOF;\r\n  }\r\n  private peek(): Token {\r\n    return this.tokens[this.current] as Token;\r\n  }\r\n}\r\n\r\nexport default Parser;\r\n", "import type { LiteralType } from './type';\r\n\r\nexport type EventType = {\r\n  print: {\r\n    value: LiteralType;\r\n  };\r\n};\r\n\r\nexport class EventEmitter<\r\n  EventType extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  protected event: Record<string, Array<(...args: unknown[]) => void>> = {};\r\n  getEventLength<T extends keyof EventType>(name: T): number {\r\n    // @ts-ignore\r\n    const temp = this.event[name];\r\n    return (temp && temp.length) || 0;\r\n  }\r\n  on<T extends keyof EventType>(\r\n    name: T,\r\n    callback: (data: EventType[T]) => void,\r\n  ): VoidFunction {\r\n    // @ts-ignore\r\n    this.event[name] = this.event[name] || [];\r\n    // @ts-ignore\r\n    this.event[name].push(callback);\r\n    return () => this.off(name, callback);\r\n  }\r\n  emitAsync<T extends keyof EventType>(name: T, data: EventType[T]): void {\r\n    // @ts-ignore\r\n    const list = this.event[name];\r\n    if (!list || list.length <= 0) {\r\n      return;\r\n    }\r\n    for (const item of list) {\r\n      window.requestAnimationFrame(() => {\r\n        item(data);\r\n      });\r\n    }\r\n  }\r\n  emit<T extends keyof EventType>(name: T, data: EventType[T]): void {\r\n    // @ts-ignore\r\n    const list = this.event[name];\r\n    if (!list || list.length <= 0) {\r\n      return;\r\n    }\r\n    for (const item of list) {\r\n      item(data);\r\n    }\r\n  }\r\n  off<T extends keyof EventType>(\r\n    name: T,\r\n    callback?: (data: EventType[T]) => void,\r\n  ): void {\r\n    const result = [];\r\n    // @ts-ignore\r\n    const events = this.event[name];\r\n    if (events && callback) {\r\n      for (const item of events) {\r\n        if (item !== callback && item._ !== callback) {\r\n          result.push(item);\r\n        }\r\n      }\r\n    }\r\n    if (result.length) {\r\n      // @ts-ignore\r\n      this.event[name] = result;\r\n    } else {\r\n      // @ts-ignore\r\n      delete this.event[name];\r\n    }\r\n  }\r\n  offAll(): void {\r\n    this.event = {};\r\n  }\r\n  once<T extends keyof EventType>(\r\n    name: T,\r\n    callback: (data: EventType[T]) => void,\r\n  ): VoidFunction {\r\n    const listener = (data: EventType[T]) => {\r\n      this.off(name, listener);\r\n      callback(data);\r\n    };\r\n    listener._ = callback;\r\n    return this.on(name, listener);\r\n  }\r\n}\r\n\r\nconst eventEmitter = new EventEmitter<EventType>();\r\nexport default eventEmitter;\r\n", "import type { LiteralType } from './type';\r\nimport type Token from './token';\r\nclass Environment {\r\n  private readonly values = new Map<string, LiteralType>();\r\n  private parent: Environment | null = null;\r\n  constructor(parent: Environment | null) {\r\n    this.parent = parent;\r\n  }\r\n  get(name: Token): LiteralType {\r\n    if (this.values.has(name.lexeme)) {\r\n      return this.values.get(name.lexeme) as LiteralType;\r\n    }\r\n    if (this.parent !== null) {\r\n      return this.parent.get(name);\r\n    }\r\n    throw new Error(`${name.lexeme} is not defined`);\r\n  }\r\n  define(name: string, value: LiteralType) {\r\n    this.values.set(name, value);\r\n  }\r\n  assign(name: Token, value: LiteralType) {\r\n    if (this.values.has(name.lexeme)) {\r\n      this.values.set(name.lexeme, value);\r\n      return;\r\n    }\r\n    if (this.parent !== null) {\r\n      this.parent.assign(name, value);\r\n      return;\r\n    }\r\n    throw new Error(`${name.lexeme} is not defined`);\r\n  }\r\n}\r\n\r\nexport default Environment;\r\n", "class Expect {\r\n  total = 0;\r\n  success = 0;\r\n  add() {\r\n    this.total++;\r\n  }\r\n  addSuccess() {\r\n    this.success++;\r\n  }\r\n}\r\nconst globalExpect = new Expect();\r\nexport default globalExpect;\r\n", "import type { LiteralType, BaseCallable } from './type';\r\nimport type Interpreter from './interpreter';\r\nimport type { FunctionStatement } from './statement';\r\nimport Environment from './environment';\r\n\r\nclass LoxCallable implements BaseCallable {\r\n  private readonly declaration: FunctionStatement<LiteralType>;\r\n  private readonly closure: Environment;\r\n  constructor(\r\n    declaration: FunctionStatement<LiteralType>,\r\n    closure: Environment,\r\n  ) {\r\n    this.declaration = declaration;\r\n    this.closure = closure;\r\n  }\r\n  call(interpreter: Interpreter, argumentList: LiteralType[]): LiteralType {\r\n    const env = new Environment(this.closure);\r\n    for (let i = 0; i < this.declaration.params.length; i++) {\r\n      env.define(this.declaration.params[i]?.lexeme!, argumentList[i]);\r\n    }\r\n    return interpreter.executeBlock(this.declaration.body, env);\r\n  }\r\n  size(): number {\r\n    return 0;\r\n  }\r\n  toString() {\r\n    return `<fn ${this.declaration.name.lexeme}>`;\r\n  }\r\n}\r\n\r\nexport { LoxCallable };\r\n", "import type { LiteralType } from './type';\r\n\r\nclass ReturnValue extends Error {\r\n  value: LiteralType;\r\n  constructor(value: LiteralType) {\r\n    super(value);\r\n    this.value = value;\r\n  }\r\n}\r\n\r\nexport { ReturnValue };\r\n", "import type { LiteralType } from './type';\r\n\r\nimport type {\r\n  BinaryExpression,\r\n  GroupingExpression,\r\n  LiteralExpression,\r\n  UnaryExpression,\r\n  AssignExpression,\r\n  CallExpression,\r\n  GetExpression,\r\n  SetExpression,\r\n  LogicalExpression,\r\n  SuperExpression,\r\n  ThisExpression,\r\n  Expression,\r\n  ExpressionVisitor,\r\n  VariableExpression,\r\n} from './expression';\r\nimport { TokenType } from './tokenType';\r\n\r\nimport type {\r\n  FunctionStatement,\r\n  IfStatement,\r\n  PrintStatement,\r\n  ReturnStatement,\r\n  StatementVisitor,\r\n  ExpressionStatement,\r\n  Statement,\r\n  BlockStatement,\r\n  WhileStatement,\r\n  ClassStatement,\r\n  VariableStatement,\r\n} from './statement';\r\n\r\nimport eventEmitter from './eventEmitter';\r\nimport Environment from './environment';\r\nimport { RuntimeError } from './error';\r\nimport globalExpect from './expect';\r\nimport { convertLiteralTypeToString, isBaseCallable, isTestEnv } from './util';\r\nimport { LoxCallable } from './loxCallable';\r\nimport { ReturnValue } from './returnValue';\r\n\r\nconst MAX_WHILE_COUNT = 15000000;\r\n\r\nclass Interpreter\r\n  implements ExpressionVisitor<LiteralType>, StatementVisitor<LiteralType>\r\n{\r\n  globals = new Environment(null);\r\n  private environment = this.globals;\r\n\r\n  interpret = (list: Statement<LiteralType>[], env: Environment): void => {\r\n    this.globals = env;\r\n    this.environment = env;\r\n    for (const item of list) {\r\n      this.execute(item);\r\n    }\r\n  };\r\n  private execute = (statement: Statement<LiteralType>) => {\r\n    return statement.accept(this);\r\n  };\r\n  private evaluate = (expr: Expression<LiteralType>): LiteralType => {\r\n    return expr.accept(this);\r\n  };\r\n  visitExpressionStatement = (statement: ExpressionStatement<LiteralType>) => {\r\n    return this.evaluate(statement.expression);\r\n  };\r\n  visitBlockStatement = (statement: BlockStatement<LiteralType>) => {\r\n    return this.executeBlock(statement, new Environment(this.environment));\r\n  };\r\n  executeBlock = (\r\n    statement: BlockStatement<LiteralType>,\r\n    environment: Environment,\r\n  ): LiteralType => {\r\n    const previous = this.environment;\r\n    let result: LiteralType | null = null;\r\n    try {\r\n      this.environment = environment;\r\n      for (let item of statement.statements) {\r\n        this.execute(item);\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof ReturnValue) {\r\n        result = error.value;\r\n      }\r\n    } finally {\r\n      this.environment = previous;\r\n    }\r\n    return result;\r\n  };\r\n  visitClassStatement = (statement: ClassStatement<LiteralType>) => {\r\n    console.log(statement);\r\n    return null;\r\n  };\r\n  visitFunctionStatement = (statement: FunctionStatement<LiteralType>) => {\r\n    this.environment.define(statement.name.lexeme, new LoxCallable(statement, this.environment));\r\n    return null;\r\n  };\r\n  visitIfStatement = (statement: IfStatement<LiteralType>) => {\r\n    if (this.isTruthy(this.evaluate(statement.condition))) {\r\n      this.execute(statement.thenBranch);\r\n    } else if (statement.elseBranch) {\r\n      this.execute(statement.elseBranch);\r\n    }\r\n    return null;\r\n  };\r\n  visitPrintStatement = (statement: PrintStatement<LiteralType>) => {\r\n    const result: LiteralType = this.evaluate(statement.expression);\r\n    console.log(result);\r\n    eventEmitter.emit('print', { value: result });\r\n    if (isTestEnv() && statement.comment !== null) {\r\n      const expect = statement.comment.lexeme;\r\n      const actual = convertLiteralTypeToString(result);\r\n      globalExpect.add();\r\n      if (expect === actual) {\r\n        globalExpect.addSuccess();\r\n      } else {\r\n        throw new Error(`visitPrintStatement expect: ${expect},actual: ${actual}, line: ${statement.comment.line}`)\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n  visitReturnStatement = (statement: ReturnStatement<LiteralType>) => {\r\n    if (statement.value !== null) {\r\n      const result = this.evaluate(statement.value);\r\n      throw new ReturnValue(result);\r\n    }\r\n    return null;\r\n  };\r\n  visitVariableStatement = (statement: VariableStatement<LiteralType>) => {\r\n    let value = null;\r\n    if (statement.initializer !== null) {\r\n      value = this.evaluate(statement.initializer);\r\n    }\r\n    this.environment.define(statement.name.lexeme, value);\r\n    return null;\r\n  };\r\n  visitWhileStatement = (statement: WhileStatement<LiteralType>) => {\r\n    let count = 0;\r\n    while (this.isTruthy(this.evaluate(statement.condition))) {\r\n      this.execute(statement.body);\r\n      count++;\r\n      if (count > MAX_WHILE_COUNT) {\r\n        throw new Error('over max while count')\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  visitAssignExpression = (expr: AssignExpression<LiteralType>) => {\r\n    const temp: LiteralType = this.evaluate(expr.value);\r\n    this.environment.assign(expr.name, temp);\r\n    return temp;\r\n  };\r\n  visitBinaryExpression = (\r\n    expr: BinaryExpression<LiteralType>,\r\n  ): LiteralType => {\r\n    const left: LiteralType = this.evaluate(expr.left);\r\n    const right: LiteralType = this.evaluate(expr.right);\r\n    switch (expr.operator.type) {\r\n      case TokenType.MINUS:\r\n        return Number(left) - Number(right);\r\n      case TokenType.PLUS:\r\n        if (typeof left === 'number' && typeof right === 'number') {\r\n          return Number(left) + Number(right);\r\n        }\r\n        if (typeof left === 'string' || typeof right === 'string') {\r\n          return String(left) + String(right);\r\n        }\r\n        if (\r\n          (typeof left === 'string' && typeof right === 'number') ||\r\n          (typeof left === 'number' && typeof right === 'string')\r\n        ) {\r\n          return String(left) + String(right);\r\n        }\r\n        return null;\r\n      case TokenType.STAR:\r\n        return Number(left) * Number(right);\r\n      case TokenType.SLASH: {\r\n        const temp = Number(right);\r\n        if (temp === 0) {\r\n          throw new Error('slash is zero');\r\n        }\r\n        return Number(left) / temp;\r\n      }\r\n\r\n      case TokenType.GREATER:\r\n        return Number(left) > Number(right);\r\n      case TokenType.GREATER_EQUAL:\r\n        return Number(left) >= Number(right);\r\n      case TokenType.LESS:\r\n        return Number(left) < Number(right);\r\n      case TokenType.LESS_EQUAL:\r\n        return Number(left) <= Number(right);\r\n      case TokenType.BANG_EQUAL:\r\n        return !this.isEqual(left, right);\r\n      case TokenType.EQUAL_EQUAL:\r\n        return this.isEqual(left, right);\r\n    }\r\n    return null;\r\n  };\r\n  visitCallExpression = (expr: CallExpression<LiteralType>): LiteralType => {\r\n    const callee: LiteralType = this.evaluate(expr.callee);\r\n    const argumentList: LiteralType[] = [];\r\n    for (let item of expr.argumentList) {\r\n      argumentList.push(this.evaluate(item));\r\n    }\r\n    if (!isBaseCallable(callee)) {\r\n      throw new RuntimeError(expr.paren, 'can only call functions');\r\n    }\r\n    return callee.call(this, argumentList);\r\n  };\r\n  visitGetExpression = (expr: GetExpression<LiteralType>) => {\r\n    return this.parenthesize(expr.name.lexeme, expr.object);\r\n  };\r\n  visitSetExpression = (expr: SetExpression<LiteralType>) => {\r\n    return this.parenthesize(expr.name.lexeme, expr.object, expr.value);\r\n  };\r\n  visitLogicalExpression = (expr: LogicalExpression<LiteralType>) => {\r\n    const left = this.evaluate(expr.left);\r\n    if (expr.operator.type === TokenType.OR) {\r\n      if (this.isTruthy(left)) {\r\n        return left;\r\n      }\r\n    } else {\r\n      if (!this.isTruthy(left)) {\r\n        return left;\r\n      }\r\n    }\r\n    return this.evaluate(expr.right);\r\n  };\r\n  visitSuperExpression = (expr: SuperExpression<LiteralType>) => {\r\n    return this.parenthesize(expr.keyword.lexeme, expr.value);\r\n  };\r\n  visitThisExpression = (expr: ThisExpression<LiteralType>) => {\r\n    return this.parenthesize(expr.keyword.lexeme);\r\n  };\r\n  visitVariableExpression = (expr: VariableExpression<LiteralType>) => {\r\n    return this.environment.get(expr.name);\r\n  };\r\n  visitGroupingExpression = (\r\n    expr: GroupingExpression<LiteralType>,\r\n  ): LiteralType => {\r\n    return this.evaluate(expr.expression);\r\n  };\r\n  visitLiteralExpression = (\r\n    expr: LiteralExpression<LiteralType>,\r\n  ): LiteralType => {\r\n    return expr.value;\r\n  };\r\n  visitUnaryExpression = (expr: UnaryExpression<LiteralType>): LiteralType => {\r\n    const right: LiteralType = this.evaluate(expr.right);\r\n    switch (expr.operator.type) {\r\n      case TokenType.MINUS:\r\n        return -Number(right);\r\n      case TokenType.BANG:\r\n        return !this.isTruthy(right);\r\n    }\r\n    return null;\r\n  };\r\n\r\n  print = (expr: Expression<LiteralType>) => {\r\n    return expr.accept(this);\r\n  };\r\n  isEqual(left: LiteralType, right: LiteralType) {\r\n    if (left === null && right === null) {\r\n      return true;\r\n    }\r\n    if (left === null) {\r\n      return false;\r\n    }\r\n    return left === right;\r\n  }\r\n  isTruthy(value: LiteralType) {\r\n    if (value === null) {\r\n      return false;\r\n    }\r\n    return Boolean(value);\r\n  }\r\n  private parenthesize(\r\n    name: string,\r\n    ...exprs: Expression<LiteralType>[]\r\n  ): LiteralType {\r\n    const list: LiteralType[] = [];\r\n    for (let expr of exprs) {\r\n      list.push(expr.accept(this));\r\n    }\r\n    return `(${name} ${list.join(' ')})`;\r\n  }\r\n}\r\n\r\nexport default Interpreter;\r\n", "const DEBUG_COLOR_LIST = [\r\n  '#0000CC',\r\n  '#0000FF',\r\n  '#0033CC',\r\n  '#0033FF',\r\n  '#0066CC',\r\n  '#0066FF',\r\n  '#0099CC',\r\n  '#0099FF',\r\n  '#00CC00',\r\n  '#00CC33',\r\n  '#00CC66',\r\n  '#00CC99',\r\n  '#00CCCC',\r\n  '#00CCFF',\r\n  '#3300CC',\r\n  '#3300FF',\r\n  '#3333CC',\r\n  '#3333FF',\r\n  '#3366CC',\r\n  '#3366FF',\r\n  '#3399CC',\r\n  '#3399FF',\r\n  '#33CC00',\r\n  '#33CC33',\r\n  '#33CC66',\r\n  '#33CC99',\r\n  '#33CCCC',\r\n  '#33CCFF',\r\n  '#6600CC',\r\n  '#6600FF',\r\n  '#6633CC',\r\n  '#6633FF',\r\n  '#66CC00',\r\n  '#66CC33',\r\n  '#9900CC',\r\n  '#9900FF',\r\n  '#9933CC',\r\n  '#9933FF',\r\n  '#99CC00',\r\n  '#99CC33',\r\n  '#CC0000',\r\n  '#CC0033',\r\n  '#CC0066',\r\n  '#CC0099',\r\n  '#CC00CC',\r\n  '#CC00FF',\r\n  '#CC3300',\r\n  '#CC3333',\r\n  '#CC3366',\r\n  '#CC3399',\r\n  '#CC33CC',\r\n  '#CC33FF',\r\n  '#CC6600',\r\n  '#CC6633',\r\n  '#CC9900',\r\n  '#CC9933',\r\n  '#CCCC00',\r\n  '#CCCC33',\r\n  '#FF0000',\r\n  '#FF0033',\r\n  '#FF0066',\r\n  '#FF0099',\r\n  '#FF00CC',\r\n  '#FF00FF',\r\n  '#FF3300',\r\n  '#FF3333',\r\n  '#FF3366',\r\n  '#FF3399',\r\n  '#FF33CC',\r\n  '#FF33FF',\r\n  '#FF6600',\r\n  '#FF6633',\r\n  '#FF9900',\r\n  '#FF9933',\r\n  '#FFCC00',\r\n  '#FFCC33',\r\n];\r\nclass Debug {\r\n  private namespace: string;\r\n\r\n  static readonly colorMap: Map<string, string> = new Map<string, string>();\r\n  constructor(namespace: string) {\r\n    this.namespace = namespace;\r\n    this.setColor();\r\n  }\r\n  init = () => {\r\n    return this.log;\r\n  };\r\n  private log = (...rest: Array<unknown>): void => {\r\n    if (!this.enable()) {\r\n      return;\r\n    }\r\n    const { namespace } = this;\r\n    const color = Debug.colorMap.get(namespace);\r\n    const result = [`%c ${namespace}:`, `color:${color};`, ...rest];\r\n    console.log(...result);\r\n  };\r\n  private enable() {\r\n    return this.checkEnable();\r\n  }\r\n  checkEnable() {\r\n    if (typeof window === 'undefined') {\r\n      if (\r\n        typeof process !== 'undefined' &&\r\n        process &&\r\n        process.env &&\r\n        process.env['DEBUG'] &&\r\n        process.env['DEBUG'] === '*'\r\n      ) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    if (\r\n      window &&\r\n      window.localStorage &&\r\n      window.localStorage.getItem &&\r\n      typeof window.localStorage.getItem === 'function'\r\n    ) {\r\n      return localStorage.getItem('debug') === '*';\r\n    }\r\n\r\n    return false;\r\n  }\r\n  private setColor() {\r\n    if (!Debug.colorMap.has(this.namespace)) {\r\n      const index = Math.floor(Math.random() * DEBUG_COLOR_LIST.length);\r\n      const color = DEBUG_COLOR_LIST[index];\r\n      if (color) {\r\n        Debug.colorMap.set(this.namespace, color);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Debug;\r\n", "import type { LiteralType, BaseCallable } from './type';\r\n\r\nclass NativeClock implements BaseCallable {\r\n  call(): LiteralType {\r\n    return Math.floor(new Date().getTime() / 1000);\r\n  }\r\n  size(): number {\r\n    return 0;\r\n  }\r\n  toString() {\r\n    return `<native fn>`;\r\n  }\r\n}\r\n\r\nexport { NativeClock };\r\n", "import Scanner from './scanner';\r\nimport Parser from './parser';\r\nimport Interpreter from './interpreter';\r\nimport Debug from './debug';\r\nimport type Environment from './environment';\r\nimport { NativeClock } from './native';\r\n\r\nconst debug = new Debug('lox').init();\r\n\r\nexport class Lox {\r\n  public run(text: string, env: Environment) {\r\n    const scanner = new Scanner(text);\r\n    const tokens = scanner.scanTokens();\r\n    debug(tokens);\r\n    const parser = new Parser(tokens);\r\n    const statements = parser.parse();\r\n    debug(statements);\r\n    const interpreter = new Interpreter();\r\n    env.define('clock', new NativeClock())\r\n    interpreter.interpret(statements, env);\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
